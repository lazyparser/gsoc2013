# HG changeset patch
# Parent aa8de5cbf6efd6ac29409f832b92ff83a981f858
# User Wei Wu <lazyparser@gmail.com>

diff --git a/js/src/ion/Ion.cpp b/js/src/ion/Ion.cpp
--- a/js/src/ion/Ion.cpp
+++ b/js/src/ion/Ion.cpp
@@ -1270,16 +1270,24 @@ GenerateCode(MIRGenerator *mir, LIRGraph
         return NULL;
 
     if (mir->compilingAsmJS()) {
         if (!codegen->generateAsmJS()) {
             js_delete(codegen);
             return NULL;
         }
     } else {
+        if (js_IonOptions.baselineBranchProfiling) {
+            if (!lir->moveUnlikelyBlocks()) {
+                IonSpew(IonSpew_BranchProfiles, "lir->reorderBlocks() FAIL!!");
+                js_delete(codegen);
+                return NULL;
+            }
+        }
+
         if (!codegen->generate()) {
             js_delete(codegen);
             return NULL;
         }
     }
 
     return codegen;
 }
diff --git a/js/src/ion/Ion.h b/js/src/ion/Ion.h
--- a/js/src/ion/Ion.h
+++ b/js/src/ion/Ion.h
@@ -214,17 +214,19 @@ struct IonOptions
         maxInlineDepth(3),
         smallFunctionMaxInlineDepth(10),
         smallFunctionMaxBytecodeLength(100),
         polyInlineMax(4),
         inlineMaxTotalBytecodeLength(1000),
         inlineUseCountRatio(128),
         eagerCompilation(false),
         usesBeforeCompilePar(1),
-        baselineBranchProfiling(false)
+        // this moditification is for test only.
+        // it will not be included in the final patch.
+        baselineBranchProfiling(true)
     {
     }
 
     uint32_t usesBeforeInlining() {
         return usesBeforeCompile * usesBeforeInliningFactor;
     }
 };
 
diff --git a/js/src/ion/LIR.cpp b/js/src/ion/LIR.cpp
--- a/js/src/ion/LIR.cpp
+++ b/js/src/ion/LIR.cpp
@@ -8,16 +8,18 @@
 
 #include "jsprf.h"
 
 #include "ion/IonSpewer.h"
 #include "ion/MIR.h"
 #include "ion/MIRGraph.h"
 #include "ion/shared/CodeGenerator-shared.h"
 
+#include "mozilla/DebugOnly.h"
+
 using namespace js;
 using namespace js::ion;
 
 LIRGraph::LIRGraph(MIRGraph *mir)
   : numVirtualRegisters_(0),
     numInstructions_(1), // First id is 1.
     localSlotCount_(0),
     argumentSlotCount_(0),
@@ -45,16 +47,66 @@ LIRGraph::noteNeedsSafepoint(LInstructio
 }
 
 void
 LIRGraph::removeBlock(size_t i)
 {
     blocks_.erase(blocks_.begin() + i);
 }
 
+bool
+LIRGraph::moveUnlikelyBlocks()
+{
+    Vector<LBlock *, 12, SystemAllocPolicy> likelyBlocks;
+    Vector<LBlock *, 4, SystemAllocPolicy> unlikelyBlocks;
+
+#ifdef DEBUG
+    for (size_t i = 0; i < numBlocks(); i++) {
+        IonSpew(IonSpew_BranchProfiles, "Dump LBlocks Before Reordering: id(%d) addr(%p)", i, getBlock(i));
+    }
+#endif
+
+    // The entry block must remain in the first place.
+    likelyBlocks.append(blocks_[0]);
+    for (size_t i = 1; i < blocks_.length(); i++) {
+        LBlock *lblock = blocks_[i];
+        JS_ASSERT(lblock);
+        MBasicBlock *mblock = lblock->mir();
+        JS_ASSERT(mblock);
+
+        // TODO: Extract this condition and place it in a separated function
+        // which would be call something like "unlikelyBlockHeurisitic".
+        if (mblock->isBlockUseCountAvailable() && mblock->getBlockUseCount() == 0) {
+            IonSpew(IonSpew_BranchProfiles, "Move LBlock (%p) to end", lblock);
+            if (!unlikelyBlocks.append(lblock))
+                return false;
+        } else {
+            IonSpew(IonSpew_BranchProfiles, "Keep LBlock (%p) in place", lblock);
+            if (!likelyBlocks.append(lblock))
+                return false;
+        }
+    }
+
+    blocks_.clear();
+    mozilla::DebugOnly<bool> ok;
+    ok = blocks_.appendAll(likelyBlocks);
+    JS_ASSERT(ok);
+    ok = blocks_.appendAll(unlikelyBlocks);
+    JS_ASSERT(ok);
+
+#ifdef DEBUG
+    for (size_t i = 0; i < numBlocks(); i++) {
+        IonSpew(IonSpew_BranchProfiles,
+                "Dump LBlocks After Reordering: id(%d) addr(%p) mblock id(%d)",
+                i, getBlock(i), getBlock(i)->mir()->id());
+    }
+#endif
+
+    return true;
+}
 Label *
 LBlock::label()
 {
     return begin()->toLabel()->label();
 }
 
 uint32_t
 LBlock::firstId()
diff --git a/js/src/ion/LIR.h b/js/src/ion/LIR.h
--- a/js/src/ion/LIR.h
+++ b/js/src/ion/LIR.h
@@ -1420,16 +1420,18 @@ class LIRGraph
     }
     size_t numSafepoints() const {
         return safepoints_.length();
     }
     LInstruction *getSafepoint(size_t i) const {
         return safepoints_[i];
     }
     void removeBlock(size_t i);
+
+    bool moveUnlikelyBlocks();
 };
 
 LAllocation::LAllocation(const AnyRegister &reg)
 {
     if (reg.isFloat())
         *this = LFloatReg(reg.fpu());
     else
         *this = LGeneralReg(reg.gpr());
