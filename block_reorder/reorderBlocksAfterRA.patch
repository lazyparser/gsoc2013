# HG changeset patch
# Parent 4e130f5d5729a163d6eb9660adee521c6b287aa9
# User Wei Wu <lazyparser@gmail.com>

diff --git a/js/src/ion/Ion.cpp b/js/src/ion/Ion.cpp
--- a/js/src/ion/Ion.cpp
+++ b/js/src/ion/Ion.cpp
@@ -1270,16 +1270,23 @@ GenerateCode(MIRGenerator *mir, LIRGraph
         return NULL;
 
     if (mir->compilingAsmJS()) {
         if (!codegen->generateAsmJS()) {
             js_delete(codegen);
             return NULL;
         }
     } else {
+        if (js_IonOptions.baselineBranchProfiling) {
+            if (!lir->reorderBlocks()) {
+                IonSpew(IonSpew_BranchProfiles, "lir->reorderBlocks() FAIL!!");
+                js_delete(codegen);
+                return NULL;
+            }
+        }
         if (!codegen->generate()) {
             js_delete(codegen);
             return NULL;
         }
     }
 
     return codegen;
 }
diff --git a/js/src/ion/Ion.h b/js/src/ion/Ion.h
--- a/js/src/ion/Ion.h
+++ b/js/src/ion/Ion.h
@@ -214,17 +214,17 @@ struct IonOptions
         maxInlineDepth(3),
         smallFunctionMaxInlineDepth(10),
         smallFunctionMaxBytecodeLength(100),
         polyInlineMax(4),
         inlineMaxTotalBytecodeLength(1000),
         inlineUseCountRatio(128),
         eagerCompilation(false),
         usesBeforeCompilePar(1),
-        baselineBranchProfiling(false)
+        baselineBranchProfiling(true)
     {
     }
 
     uint32_t usesBeforeInlining() {
         return usesBeforeCompile * usesBeforeInliningFactor;
     }
 };
 
diff --git a/js/src/ion/LIR.cpp b/js/src/ion/LIR.cpp
--- a/js/src/ion/LIR.cpp
+++ b/js/src/ion/LIR.cpp
@@ -45,16 +45,66 @@ LIRGraph::noteNeedsSafepoint(LInstructio
 }
 
 void
 LIRGraph::removeBlock(size_t i)
 {
     blocks_.erase(blocks_.begin() + i);
 }
 
+bool
+LIRGraph::reorderBlocks()
+{
+    Vector<LBlock *, 12, SystemAllocPolicy> usedBlocks;
+    Vector<LBlock *, 4, SystemAllocPolicy> unusedBlocks;
+
+#ifdef DEBUG
+    for (size_t i = 0; i < numBlocks(); i++) {
+        IonSpew(IonSpew_BranchProfiles, "Dump LBlocks Before Reordering: id(%d) addr(%p)", i, getBlock(i));
+    }
+#endif
+
+    // Do not pop the first block (entry block).
+    while (blocks_.length() > 1) {
+        LBlock *lblock = blocks_.popCopy();
+        JS_ASSERT(lblock);
+        MBasicBlock *mblock = lblock->mir();
+        JS_ASSERT(mblock);
+        if (mblock->isBlockUseCountAvailable() && mblock->getBlockUseCount() == 0) {
+            IonSpew(IonSpew_BranchProfiles, "Move LBlock (%p) to end", lblock);
+            if (!unusedBlocks.append(lblock))
+                return false;
+        } else {
+            IonSpew(IonSpew_BranchProfiles, "Keep LBlock (%p) in place", lblock);
+            if (!usedBlocks.append(lblock))
+                return false;
+        }
+    }
+
+    while (usedBlocks.length()) {
+        if (!blocks_.append(usedBlocks.popCopy()))
+            return false;
+    }
+    //if (blocks_.appendAll(usedBlocks))
+
+    while (unusedBlocks.length()) {
+        if (!blocks_.append(unusedBlocks.popCopy()))
+            return false;
+    }
+
+#ifdef DEBUG
+    for (size_t i = 0; i < numBlocks(); i++) {
+        IonSpew(IonSpew_BranchProfiles,
+                "Dump LBlocks After Reordering: id(%d) addr(%p) mblock id(%d)",
+                i, getBlock(i), getBlock(i)->mir()->id());
+    }
+#endif
+
+    return true;
+}
 Label *
 LBlock::label()
 {
     return begin()->toLabel()->label();
 }
 
 uint32_t
 LBlock::firstId()
diff --git a/js/src/ion/LIR.h b/js/src/ion/LIR.h
--- a/js/src/ion/LIR.h
+++ b/js/src/ion/LIR.h
@@ -1420,16 +1420,18 @@ class LIRGraph
     }
     size_t numSafepoints() const {
         return safepoints_.length();
     }
     LInstruction *getSafepoint(size_t i) const {
         return safepoints_[i];
     }
     void removeBlock(size_t i);
+
+    bool reorderBlocks();
 };
 
 LAllocation::LAllocation(const AnyRegister &reg)
 {
     if (reg.isFloat())
         *this = LFloatReg(reg.fpu());
     else
         *this = LGeneralReg(reg.gpr());
