# HG changeset patch
# Parent a66d94476e535e31d23c1235c3368da47999e2d3
# User Wei Wu <lazyparser@gmail.com>
Bug 906418 IonMonkey: Decouple the stack state from graph traversal order of LIR blocks. r=

diff --git a/js/src/jit/CodeGenerator.cpp b/js/src/jit/CodeGenerator.cpp
--- a/js/src/jit/CodeGenerator.cpp
+++ b/js/src/jit/CodeGenerator.cpp
@@ -2610,16 +2610,19 @@ CodeGenerator::generateBody()
     IonScriptCounts *counts = maybeCreateScriptCounts();
 
 #if defined(JS_ION_PERF)
     PerfSpewer *perfSpewer = &perfSpewer_;
     if (gen->compilingAsmJS())
         perfSpewer = &gen->perfSpewer();
 #endif
 
+#ifdef DEBUG
+    js::Vector<uint32_t, 0, SystemAllocPolicy> pushedArgumentSlotsMirror;
+#endif
     for (size_t i = 0; i < graph.numBlocks(); i++) {
         current = graph.getBlock(i);
 
         LInstructionIterator iter = current->begin();
 
         // Separately visit the label at the start of every block, so that
         // count instrumentation is inserted after the block label is bound.
         if (!iter->accept(this))
@@ -2632,16 +2635,27 @@ CodeGenerator::generateBody()
             if (!blockCounts.ref().init())
                 return false;
         }
 
 #if defined(JS_ION_PERF)
         perfSpewer->startBasicBlock(current->mir(), masm);
 #endif
 
+#ifdef DEBUG
+        pushedArgumentSlotsMirror.appendAll(pushedArgumentSlots_);
+#endif
+        pushedArgumentSlots_.clear();
+        for (size_t i = 0; i < current->pushedArguments.length(); i++) {
+            if (current->pushedArguments[i]->accept(this))
+                return false;
+        }
+#ifdef DEBUG
+        JS_ASSERT(pushedArgumentSlotsMirror.length() == pushedArgumentSlots_.length());
+#endif
         for (; iter != current->end(); iter++) {
             IonSpew(IonSpew_Codegen, "instruction %s", iter->opName());
 
             if (counts)
                 blockCounts.ref().visitInstruction(*iter);
 
             if (iter->safepoint() && pushedArgumentSlots_.length()) {
                 if (!markArgumentSlots(iter->safepoint()))
diff --git a/js/src/jit/Ion.cpp b/js/src/jit/Ion.cpp
--- a/js/src/jit/Ion.cpp
+++ b/js/src/jit/Ion.cpp
@@ -1262,16 +1262,21 @@ GenerateLIR(MIRGenerator *mir)
 
     // Now that all optimization and register allocation is done, re-introduce
     // critical edges to avoid unnecessary jumps.
     if (!UnsplitEdges(lir))
         return NULL;
     IonSpewPass("Unsplit Critical Edges");
     AssertBasicGraphCoherency(graph);
 
+    if (!PropagatePushedArguments(lir))
+        return NULL;
+    IonSpewPass("Propagate Pushed Arguments");
+    AssertBasicGraphCoherency(graph);
+
     return lir;
 }
 
 CodeGenerator *
 GenerateCode(MIRGenerator *mir, LIRGraph *lir, MacroAssembler *maybeMasm)
 {
     CodeGenerator *codegen = js_new<CodeGenerator>(mir, lir, maybeMasm);
     if (!codegen)
diff --git a/js/src/jit/IonAnalysis.cpp b/js/src/jit/IonAnalysis.cpp
--- a/js/src/jit/IonAnalysis.cpp
+++ b/js/src/jit/IonAnalysis.cpp
@@ -1607,16 +1607,48 @@ ion::UnsplitEdges(LIRGraph *lir)
         lir->mir().removeBlock(mirBlock);
         --i;
     }
 
     return true;
 }
 
 bool
+ion::PropagatePushedArguments(LIRGraph *lir)
+{
+    js::Vector<LInstruction *, 0, SystemAllocPolicy> pushedArguments;
+    for (size_t i = 0; i < lir->numBlocks(); i++) {
+        LBlock *block = lir->getBlock(i);
+        block->pushedArguments.appendAll(pushedArguments);
+        size_t numPoped = 0;
+        for (LInstructionIterator iter = block->begin(); iter != block->end(); iter++) {
+            if (iter->isStackArgT() || iter->isStackArgV()) {
+                pushedArguments.append(*iter);
+            }
+            if (iter->isCallNative()) {
+                numPoped = iter->toCallNative()->numStackArgs() + 1;
+            } else if (iter->isCallDOMNative()) {
+                numPoped = iter->toCallDOMNative()->numStackArgs() + 1;
+            } else if (iter->isCallGeneric()) {
+                numPoped = iter->toCallGeneric()->numStackArgs() + 1;
+            } else if (iter->isCallKnown()) {
+                numPoped = iter->toCallKnown()->numStackArgs() + 1;
+            }
+            while (numPoped) {
+                JS_ASSERT(pushedArguments.length());
+                pushedArguments.popBack();
+                --numPoped;
+            }
+        }
+    }
+    JS_ASSERT(pushedArguments.length() == 0);
+    return true;
+}
+
+bool
 LinearSum::multiply(int32_t scale)
 {
     for (size_t i = 0; i < terms_.length(); i++) {
         if (!SafeMul(scale, terms_[i].scale, &terms_[i].scale))
             return false;
     }
     return SafeMul(scale, constant_, &constant_);
 }
diff --git a/js/src/jit/IonAnalysis.h b/js/src/jit/IonAnalysis.h
--- a/js/src/jit/IonAnalysis.h
+++ b/js/src/jit/IonAnalysis.h
@@ -63,16 +63,19 @@ void
 AssertExtendedGraphCoherency(MIRGraph &graph);
 
 bool
 EliminateRedundantChecks(MIRGraph &graph);
 
 bool
 UnsplitEdges(LIRGraph *lir);
 
+bool
+PropagatePushedArguments(LIRGraph *lir);
+
 class MDefinition;
 
 // Simple linear sum of the form 'n' or 'x + n'.
 struct SimpleLinearSum
 {
     MDefinition *term;
     int32_t constant;
 
diff --git a/js/src/jit/LIR.h b/js/src/jit/LIR.h
--- a/js/src/jit/LIR.h
+++ b/js/src/jit/LIR.h
@@ -741,16 +741,19 @@ class LBlock : public TempObject
 
     LBlock(MBasicBlock *block)
       : block_(block),
         entryMoveGroup_(NULL),
         exitMoveGroup_(NULL)
     { }
 
   public:
+    js::Vector<LInstruction *, 0, SystemAllocPolicy> pushedArguments;
+
+  public:
     static LBlock *New(MBasicBlock *from) {
         return new LBlock(from);
     }
     void add(LInstruction *ins) {
         instructions_.pushBack(ins);
     }
     bool addPhi(LPhi *phi) {
         return phis_.append(phi);
