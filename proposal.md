# Implement Branch Prediction in IonMonkey

This is a draft version. Your comments are welcome!

## Abstract:
Profiled guided branch prediction is a known optimization in compiler.
As of today, nobody tried to take advantage of this optimization on JavaScript.
The goal of this GSoC project is to analyze the benefit of such approach on
JavaScript by implementing one in SpiderMonkey (Firefox's JavaScript Engine).
The first step is to instrument the code generated by the baseline compiler
to profile branches which are executed.
Then use this information to reduce and improve IonMonkey's compilation by
filtering out branches which are infrequently used.

### Introduction
Profile Guided Optimizations have been adopted by modern compilers, such as
LLVM and many JIT compilers in Java Virtual Machines.
Lots of optimizations can benefit from the profiling data to generate
faster codes.
Currently IonMonkey lacks the mechanism to gather branch profiling information
and has to use heuristics to guess the probability of each conditional jump.
These heuristics are usually conservative and may block further (aggressive)
optimization opportunities.

By introducing the branch profiling data IonMonkey can aggressively remove
the infrequently used basic blocks and therefore simplify subsequent analyses
like type inference and alias analysis.
Nicolas Pierron, an IonMonkey developer, suggested that other optimizations
such as GVN & LICM might benefit from the profiling information even if
branches were not removed.


### Project scope
Ideally, all analyses and optimizations existing in IonMonkey might benefit
from the branch usage profiles.
Thus, we should investigate the impact of this optimization of other analysis.
The profiling module should be able to gather multiple types of running
information other than conditional jumps only.
However, this project will implement the branch profiling functionality
in baseline compiler and a MIR transformation pass,
due to the time limitation of a GSoC project.


### Technical details
This project can be divided into two parts, i.e.
the profiling module and the MIR transformation pass.
I will describe the details of them in this section.

#### Branch Profiling Module
Branch Profiling Module (BPM) collects the targets of conditional jumps by
instrumenting SpiderMonkey engine.
There are three potential instrumentation points in SpiderMonkey: the bytecode
interpreter, IonMonkey and the baseline compiler.
Instrumenting interpreter is the easiest way to get things work but the the data
it collects is fragmented and less important, since "hot" JavaScript methods
are not executed by interpreter.
IonMonkey is another place that can insert profiling code but the overhead
caused by profiling makes it unpractical.
BPM leverages the Baseline Compiler to generate instrumented machine codes.
BPM replaces the output of baseline compiler when it generates code for
JSOP_IFEQ, JSOP_IFNE, and JSOP_TABLESWITCH bytecodes.


BPM uses a circular buffer to store data and allocates one buffer for each
IonScript object.
Every time BPM is triggered it pushes both the address of the conditional jump
instruction and the target address it jumps to.
Main benefits of this design are that not only frequencies of each branch can be
calculated but also the relationships between jumps are able to be inferred
by advanced algorithms.

BPM can be switched on/off through command line options or browser's
configuration panel.
Also it can be turned on/off via JSAPIs.
The design of the interface would be like this:

> JS_IsBranchProfilingEnabled(JSContext* cx);

> JS_EnableBranchProfiling(JSContext* cx);

> JS_DisableBranchProfiling(JSContext* cx);

Although BPM can only be switched on/off at JSContext granularity outside
SpiderMonkey, it stores a profiling status flag in IonScript so that
SpiderMonkey has the ability to profile a JSScript (IonScript) individually.


#### MIR Branch Pruning Pass
The Branch Pruning Pass (BPP) is invoked right after the MIR is generated
by IonBuilder.
Based on the probabilities converted from the branch profiling buffer,
BPP speculatively removes unused or infrequently used basic blocks.
After the removal of "cold branches", BPP is able to reduce the type sets
and simplify the work of alias analysis.


The main drawback of pruning branches is that when the pruned branch is taken
a bailout will occur.
The more basic blocks are removed the more bailouts may occur.
One goal of this project is to find out the balance point between the
aggressiveness of pruning and the costs of bailout.

### Schedule of Deliverables
#### Deliverables
The final deliverables would consist of: 
- A patch that implements Circular Buffer utility and related test cases.
- A patch that implements Branch Profiling Module and related test cases.
- A patch that implements MIR Branch Pruning Pass and related test cases.
- A technical report illustrating the relationships among the aggressiveness
of pruning, type inference, alias analysis and the costs of bailout.

#### Schedule
- Week 1 - Week 2: Discuss the project details with my mentor.
Get familiar with the JS Engine team.

- Week 3 - Week 4: Implement the Circular Buffer. Test and fix bugs.
- Week 5 - Week 6: Implement the Branch Profiling prototype; instrument the
machine codes generated by baseline compiler.
- Week 7 - Week 8: Add the convert function to Branch Profiling class.
Modify related MIR nodes to store the probability data.
- Week 9 - Week 11: Implement the prototype of Branch Pruning Pass.

- Week 12 - Week 14: Benchmark the performance impact of BPM and BPP with
different pruning policies. Test and fix the bugs in BPP.
- Week 15 - Week 16: Prepare the technical report. Submit patches.


### Open Source Development Experience
Hidden.

### Work/Internship Experience
Hidden.

### Academic Experience
Hidden.

### Why Me
Hidden.

### Why Mozilla
Hidden.
