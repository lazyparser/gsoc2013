# Implement Branch Prediction in IonMonkey

This is a draft version. Your comments are welcome!

## Abstract:
Profile guided branch prediction is a known optimization in compiler.
As of today, nobody tried to take advantage of this optimization on JavaScript.
The goal of this GSoC project is to analyze the benefit of such approach on
JavaScript by implementing one in SpiderMonkey (Firefox's JavaScript Engine).
The first step is to instrument the code generated by the baseline compiler
to profile branches which are executed.
Then use this information to reduce and improve IonMonkey's compilation by
filtering out branches which are infrequently used.

## Project Proposal
### Introduction
Profile Guided Optimizations have been adopted by modern compilers, such as
LLVM and many JIT compilers in Java Virtual Machines.
Lots of optimizations can benefit from the profiling data to generate
faster and smaller codes.
SpiderMonkey is able to collect some sorts of profiling
information during the execution of JavaScript programs.
For example, the interpreter and the baseline compiler gather each variable's
type information, which is used in multiple optimizations in IonMonkey,
SpiderMonkey's newest method-based Just-In-Time compiler.

Currently SpiderMonkey lacks the mechanism to obtain branch profiling
information and has no heuristic to guess the probability of each conditional jump.
Basic blocks could not be removed unless IonMonkey can prove that
they are not reachable.
By introducing the branch profiling data IonMonkey will have the ability to aggressively
filter out the infrequently used basic blocks and therefore simplify subsequent
analyses like type inference and alias analysis.
Nicolas Pierron, an IonMonkey developer, suggested that other optimizations
such as GVN & LICM might benefit from the profiling information even if
branches were not removed.

The main difference between the Unreachable Code Elimination (UCE) and
our method is that UCE guarantees the removal of branches are safe,
while the branches filtered out in our method might be accessed under particular
circumstances.
In this case our method generates a bailout and return the control back to the interpreter.
The cost of bailout is not free. In fact the switch between the interpreter and
machine codes should be reduced as possible as we can.
A basic block is worth to be filtered out only when the benefits we get are
bigger than the cost of the bailout we introduced.
Thus, it is necessary to assess the impact on the analyses and optimizations
implemented in IonMonkey.

The first goal of this project is to instrument the code generated by the
baseline compiler to get branch profiles and then use these profiles to filter out
infrequently used branches. The second goal is to analyze the benefit of
such approach and the impact on other analyses and transformations.

### Project scope
Ideally, all analyses and optimizations existing in IonMonkey might benefit
from the branch usage profiles.
Thus, we should investigate the impact of this optimization on all other analyses.
However it may not be possible due to the time limitation of the GSoC project.
In this project I will focus on Constant Propagation, Range Analysis,
Type Inference and Register Allocation. More analysis work would be performed
if the tasks of this project are finished ahead of schedule.


### Technical details
Design choices and implementation details are described in this section.
The first part illustrates how we instrument the machine code generated by
the baseline compiler; the second part provides the implement details of
the branch pruning pass; the last part describes the interface of branch
prediction with a few code examples.

#### Branch Profiler
Branch Profiler collects the targets of conditional jumps by
instrumenting SpiderMonkey engine.
There are three potential instrumentation points in SpiderMonkey: the bytecode
interpreter, IonMonkey and the baseline compiler.
Instrumenting interpreter is the easiest way to get things work but the the data
it collects is fragmented and less important, since "hot" JavaScript methods
are not executed by interpreter.
More importantly, Instrumenting interpreter will slow down scripts which are running
only once.
IonMonkey is another place that can insert profiling code and in fact it do has
the PCCount interface for profiling, but this mechanism is activated in debug
build only, since the overhead caused by profiling makes it unpractical.

Branch Profiler leverages the Baseline Compiler to generate instrumented machine codes.
It replaces the output of baseline compiler when it generates code for
JSOP_IFEQ, JSOP_IFNE, and JSOP_TABLESWITCH bytecodes.

Basic block counter and circular address buffer are two possible ways to store branch
profiling data.
The basic block counter solution keeps two counters for each branch,
as well as the number of the targets the branch might jump.
When a block jumps to another the correlate counter will be increased by 1.
Then these frequencies will be transformed into probabilities and consumed by
some transform passes.
On the other hand, circular address buffer maintains a sequence of branch targets.
Every time Branch Profiler is triggered it pushes the target address of the branch into buffer.
The main benefit of this design is that not only frequencies of each branch can be
calculated but also the relationships between jumps are able to be inferred,
which may generate new possibilities for more sophisticated optimizations.

In this project we choose the circular buffer as our preliminary implementation and
allocates one circular buffer for each IonScript. 
We will switch to basic block counter later if the overhead caused by the circular buffer
is high, or if we fail to find any benchmark which can take advantage of
a more-clever way of inferring branches ordering.

#### MIR Branch Pruning Pass
The Branch Pruning Pass speculatively filters out unused or infrequently used
basic blocks, based on the branch probabilities converted from the circular buffer.
Unlike Unreachable Code Elimination, basic blocks that filtered out by
the branch pruning pass are not actually removed from the MIRGraph.
Instead, we reuse the basic block as a container for bailout instructions.

At the beginning of the pass it calls the branch profiler to calculate the
execution probability of each basic block. Then the pruning pass iterates
basic blocks to mark "cold" basic block, which means that the probability of this
basic block is lower than a threshold. When a basic block is marked "cold", 
the instructions inside the basic block and the edges starting
from the basic block will be removed; a bailout instruction will be insert into
this basic block; def-use chains and type sets will be updated.

After the removal of "cold" branches, the MIRGraph might be changed,
in this case we have to rebuild the dominator tree and re-analyze the control
flow graph. In order to avoid recalculations the pruning pass is invoked
right after the MIRGraph has been generated by IonBuilder.

The main drawback of pruning branches is that when the pruned branch is taken
a bailout must occur.
The more basic blocks are filtered out the more bailouts may occur.
One goal of this project is to find out the balance point between the
aggressiveness of pruning and the costs of bailout.

#### Interface
The Branch Profiler can be switched on/off through either command line or the
configuration panel existing in the browser.
It stores the config information as a JSOPTION by declaring a new macro,
thus it can be turned on/off via JS_Option APIs.
The design of the interface would be like this:

> \#define JSOPTION_BRANCHPROFILING         JS_BIT(23)      /* Branch profiling in the baseline compiler */
>
> JS_SetOptions(cx, JSOPTION_BRANCHPROFILING);
>
> JS_ToggleOptions(cx, JSOPTION_BRANCHPROFILING);
>
> ./jsshell/js --enable-branch-profiling
>
> ./jsshell/js --disable-branch-profiling

Although the branch profiler can only be switched on/off at JSContext granularity outside
SpiderMonkey, it stores a profiling status flag in IonScript so that
SpiderMonkey has the ability to profile a JSScript (IonScript) individually.

The Branch Pruning Pass can be enabled/disabled as a normal optimization pass
existing in IonMonky. It stores the control flag and the threshold value in js_IonOptions,
which is the singleton instance of IonOptions.
The design of the interface would be like this:

> ./jsshell/js --enable-branch-pruning
>
> ./jsshell/js --disable-branch-pruning
>
> ./jsshell/js --branch-pruning-threshold={none,conservative,optimal,eager}

### Schedule of Deliverables
#### Deliverables
The final deliverables would consist of: 
- A Branch Profiler, which instruments the code generated by the baseline compiler and
converts the branch profiling data into possibilities.
- A Branch Pruning Pass, which filters out infrequently used basic blocks based on the
branch profiles.

#### Schedule
- Week 1 : Study the benchmark to find out the JavaScript programs that may benefit
from branch prediction. (1 week)
- Week 2 - 4: Implement the Branch Profiler using the circular buffer data structure;
Profile Kraken and Octane benchmarks and assess the overhead caused by profiling;
Implement a basic block counter version if the overhead keeps high. (3 weeks)
- Week 5 - 7: Implement the Branch Pruning Pass. I allocate 3 weeks for it due to
the dependencies and complexities in the IonMonkey.
- Week 8 - 9: Benchmark the performance impact of the branch profiler and pruning
pass. Test different pruning policies. Find a balance point between the
aggressiveness of pruning and the costs of bailout.
- Week 10 - 13: Analyze the impact on other IonMonkey optimizations. I will focus on
Constant Propagation, Range Analysis, Type Inference and Register Allocation.

### Open Source Development Experience
Hidden.

### Work/Internship Experience
Hidden.

### Academic Experience
Hidden.

### Why Me
Hidden.

### Why Mozilla
Hidden.
