# Implement Branch Prediction in IonMonkey

This is a draft version. Your comments are welcome!

## Abstract:
Profile guided branch prediction is a known optimization in compiler.
As of today, nobody tried to take advantage of this optimization on JavaScript.
The goal of this GSoC project is to analyze the benefit of such approach on
JavaScript by implementing one in SpiderMonkey (Firefox's JavaScript Engine).
The first step is to instrument the code generated by the baseline compiler
to profile branches which are executed.
Then use this information to reduce and improve IonMonkey's compilation by
filtering out branches which are infrequently used.

## Project Proposal
### Introduction
Profile Guided Optimizations have been adopted by modern compilers, such as
LLVM and many JIT compilers in Java Virtual Machines.
Lots of optimizations can benefit from the profiling data to generate
faster and smaller codes.
SpiderMonkey is able to collect some sorts of profiling
information during the execution of JavaScript programs.
For example, the interpreter and the baseline compiler gather each variable's
type information, which is used in multiple optimizations in IonMonkey,
SpiderMonkey's newest method-based Just-In-Time compiler.

Currently SpiderMonkey lacks the mechanism to obtain branch profiling
information and has no heuristic to guess the probability of each conditional jump.
Basic blocks could not be removed unless IonMonkey can prove that
they are not reachable.
By introducing the branch profiling data IonMonkey will have the ability to aggressively
remove the infrequently used basic blocks and therefore simplify subsequent
analyses like type inference and alias analysis.
Nicolas Pierron, an IonMonkey developer, suggested that other optimizations
such as GVN & LICM might benefit from the profiling information even if
branches were not removed.

The main difference between the Unreachable Code Elimination (UCE) and
our method is that UCE guarantees the remove of branches are safe,
while the branches filtered out in our method might be accessed under particular
circumstances.
In this case our method generates a bailout and return the control back to the interpreter.
The cost of bailout is not free. In fact the switch between the interpreter and
machine codes should be reduced as possible as we can.
A basic block is worth to be filtered out only when the benefits we get are
bigger than the cost of the bailout we introduced.
Thus, it is necessary to assess the impact on the analyses and optimizations
implemented in IonMonkey.

The first goal of this project is to instrument the code gererated by the
baseline compiler to get branch profiles and then use these profiles to filter out
infrequently used branches. The second goal is to analyze the benefit of
such approach and the impact on other analyses and transformations.

### Project scope
Ideally, all analyses and optimizations existing in IonMonkey might benefit
from the branch usage profiles.
Thus, we should investigate the impact of this optimization on all other analyses.
However it may not be possible due to the time limitation of the GSoC project.
In this project I will focus on Constant Propagation, Range Analysis,
Type Inference and Register Allocation. More analysis work would be performed
if the tasks of this project are finished ahead of schedule.


### Technical details
Design choices and implementation details are described in this section.
The first part illustrates how we instrument the machine code generated by
the baseline compiler; the second part provides the implement details of
the branch pruning pass; the last part describes the interface of branch
prediction with a few code examples.

#### Branch Profiler
Branch Profiler collects the targets of conditional jumps by
instrumenting SpiderMonkey engine.
There are three potential instrumentation points in SpiderMonkey: the bytecode
interpreter, IonMonkey and the baseline compiler.
Instrumenting interpreter is the easiest way to get things work but the the data
it collects is fragmented and less important, since "hot" JavaScript methods
are not executed by interpreter.
More importantly, Instrumenting interpreter will slow down scripts which are running
only once.
IonMonkey is another place that can insert profiling code and in fact it do has
the PCCount interface for profiling, but this mechanism is activated in debug
build only, since the overhead caused by profiling makes it unpractical.

Branch Profiler leverages the Baseline Compiler to generate instrumented machine codes.
It replaces the output of baseline compiler when it generates code for
JSOP_IFEQ, JSOP_IFNE, and JSOP_TABLESWITCH bytecodes.

Basic block counter and circular address buffer are two possible ways to store branch
profiling data.
The basic block counter solution keeps two counters for each branch,
as well as the number of the targets the branch might jump.
When a block jumps to another the correlate counter will be increased by 1.
Then these frequencies will be transformed into probabilities and consumed by
some transform passes.
On the other hand, circular address buffer maintains a sequence of branch targets.
Every time Branch Profiler is triggered it pushes the target address of the branch into buffer.
The main benefit of this design is that not only frequencies of each branch can be
calculated but also the relationships between jumps are able to be inferred,
which may generate new prossibilities for more sophisticated optimizations.

In this project we choose the circular buffer as our preliminary implementation and
allocates one circular buffer for each IonScript. 
We will switch to basic block counter later if the overhead caused by the circular buffer
is high, or if we fail to find any benchmark which can take advantage of
a more-clever way of inferring branches ordering.

#### MIR Branch Pruning Pass
The Branch Pruning Pass (BPP) is invoked right after the MIR is generated
by IonBuilder.
Based on the probabilities converted from the branch profiling buffer,
BPP speculatively removes unused or infrequently used basic blocks.
After the removal of "cold branches", BPP is able to reduce the type sets
and simplify the work of alias analysis.

The main drawback of pruning branches is that when the pruned branch is taken
a bailout will occur.
The more basic blocks are removed the more bailouts may occur.
One goal of this project is to find out the balance point between the
aggressiveness of pruning and the costs of bailout.

#### Interface
Branch Profiler can be switched on/off through either command line or the
configuration panel existing in the browser.
It stores the config information as a JSOPTION by decalaring a new macro,
thus it can be turned on/off via JS_Options APIs.
The design of the interface would be like this:

> \#define JSOPTION_BRANCHPROFILING         JS_BIT(23)      /* Branch profiling in the baseline compiler */

> JS_SetOptions(cx, JSOPTION_BRANCHPROFILING);

> JS_ToggleOptions(cx, JSOPTION_BRANCHPROFILING);

Although Branch Profiler can only be switched on/off at JSContext granularity outside
SpiderMonkey, it stores a profiling status flag in IonScript so that
SpiderMonkey has the ability to profile a JSScript (IonScript) individually.

### Schedule of Deliverables
#### Deliverables
The final deliverables would consist of: 
- A patch that implements Circular Buffer utility and related test cases.
- A patch that implements Branch Profiler and related test cases.
- A patch that implements MIR Branch Pruning Pass and related test cases.
- A technical report illustrating the relationships among the aggressiveness
of pruning, type inference, alias analysis and the costs of bailout.

#### Schedule
- Week 1 - Week 2: Discuss the project details with my mentor.
Get familiar with the JS Engine team.

- Week 3 - Week 4: Implement the Circular Buffer. Test and fix bugs.
- Week 5 - Week 6: Implement the Branch Profiling prototype; instrument the
machine codes generated by baseline compiler.
- Week 7 - Week 8: Add the convert function to Branch Profiling class.
Modify related MIR nodes to store the probability data.
- Week 9 - Week 11: Implement the prototype of Branch Pruning Pass.
- Week 12 - Week 14: Benchmark the performance impact of Branch Profiler and BPP with
different pruning policies. Test and fix the bugs in BPP.
- Week 15 - Week 16: Prepare the technical report. Submit patches.


### Open Source Development Experience
Hidden.

### Work/Internship Experience
Hidden.

### Academic Experience
Hidden.

### Why Me
Hidden.

### Why Mozilla
Hidden.
